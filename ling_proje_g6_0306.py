# -*- coding: utf-8 -*-
"""LING_Proje_G6_0306.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V5y-fPlHU4aGCokwg1v8lcFhtqfn8uK6
"""

#importing necessary libraries and our dataset
# The data is from Kaggle, Food.com Recipes and Interactions

#install HF sentence-transformers
!pip install sentence-transformers --quiet
#import time to evaluate process time as evaluation metrics
import time
import pandas as pd

!kaggle datasets download -d 'shuyangli94/food-com-recipes-and-user-interactions'
!unzip -o -q 'food-com-recipes-and-user-interactions.zip'
recipe_data = pd.read_csv("RAW_recipes.csv")

#import the SentenceTransformer
from sentence_transformers import SentenceTransformer

# The model is all-MiniLM-L6-v2 in HuggingFace. It is pretrained by 1B pairs.
model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')

# How diverse is our data? Using the keyword vegan as an example
tag = "Vegan"

count = recipe_data[recipe_data.iloc[:, 5].str.contains(tag, case=False, na=False)].shape[0]

print(f"Number of occurrences of '{tag}' in column at index 5: {count}")


# Counter,

# Asian: 13485
# Vegetarian: 35651
# Vegan: 10012
# Turkish: 286
# North-American: 48479
# Mexican: 6694
# Breakfast: 13655
# Main Dish: 71786
# Kid friendly: 27075
# No Cooking: 6194
# 15 Minutes or Less: 43934
# 60 Minutes or Less: 69990

# Grouped by country, vegetarian or vegan, and which part of the day.

#time evaluation starts
start_time = time.time()

#Getting user input for what she/he wants to eat and encoding it in transformer model

user_input = input("What are you craving?: ")

input_encoded = model.encode(user_input)

print(user_input)

recipe_data.head(20)

# define function to calculate the cosine similarity
# between two numpy arrays (vectors)
import numpy as np

def cosine_similarity(v1,v2):
    "return the cosine similarity between two vectors"

    # calculate the dot product of v1 & v2
    dot_product = np.dot(v1,v2)

    #calculate the norms of v1 & v2
    norm_1 = np.linalg.norm(v1)
    norm_2 = np.linalg.norm(v2)

    # return the cosine similarity
    return dot_product / (norm_1 * norm_2)

#encoding the ingredients form our data for transformer model than comparing it with the user input using cosine similarity function
#extracting the max similar 5 recipes
cosine_list=[]
for index, row in recipe_data.head(5000).iterrows():
    value = str(row.iloc[10])  # Extract value from the 11th column (index 10)
    value_encoded = model.encode(value)
    cosine_list.append(cosine_similarity(input_encoded,value_encoded))

import heapq


# Get the indexes of the maximum 5 values
max_similar = heapq.nlargest(5, range(len(cosine_list)), key=cosine_list.__getitem__)
#print(max_similar)


similar_recipe_ingredients = []
for i in max_similar:
  #similar_recipe_ingredients.append(recipe_data.iloc[i, 0])
  similar_recipe_ingredients.append(recipe_data.iloc[i, 10])
for i in range(len(similar_recipe_ingredients)):
  print(similar_recipe_ingredients[i])

#Asking user for what does she/he already have as ingredients
user_input_ingredient=input("What do you have in your fridge?: ")

# define function to calculate the jaccard distance between two sets
def jaccard_distance(s1, s2):

    A = set(s1)
    B = set(s2)

    intersection = len(A.intersection(B))
    union = len(A.union(B))

    return 1 - intersection/union

#Using jaccard distance function, we are calculating the distance between users ingredients and recipe's required ingredients to find out which in 5 recipes is the most useful for the user
distance=[]
most_similar = ""

for i in similar_recipe_ingredients:
  #print(f"distance between {i} and {user_input_ingredient} is: {jaccard_distance(user_input_ingredient,i)}")
  distance.append(jaccard_distance(user_input_ingredient,i))
most_similar=distance.index(min(distance))
#print(similar_recipe_ingredients[most_similar])

#print(f"I have an amazing suggestion for you: {recipe_data.iloc[max_similar[most_similar], 0]}. If you would like to try it, here is the recipe: {recipe_data.iloc[max_similar[most_similar], 8]} ")

#With this code, the recipe prints as a list with several strings. Regex deletes the symbols [ and ]. Also, seperates the strings with a comma.
# In some of the outputs, a single quotation mark is preceded by a backslash \. This code deletes them too.

import re

def clean_recipe(recipe_text):
    cleaned_text = re.sub(r'\[|\]|\'|"', '', recipe_text)
    cleaned_text = re.sub(r"\\", "'", cleaned_text)
    cleaned_text = re.sub(r'\s+', ' ', cleaned_text)
    cleaned_text = re.sub(r'\s,', ',', cleaned_text)

    return cleaned_text.strip().capitalize()

def clean_recipe_name(recipe_name):

    cleaned_recipe_name = re.sub(r'\s+', ' ', recipe_name)

    return cleaned_recipe_name

most_similar_index = max_similar[most_similar]

recipe_name = recipe_data.iloc[most_similar_index, 0]
recipe_text = recipe_data.iloc[most_similar_index, 8]
cleaned_recipe_name = clean_recipe_name(recipe_name.title())
cleaned_recipe_text = clean_recipe(recipe_text)


recipe_ingredients = recipe_data.iloc[most_similar_index, 10]
cleaned_recipe_ingredients = clean_recipe(recipe_ingredients)

cleaned_recipe_ingredients_list=cleaned_recipe_ingredients.lower().split(", ")
user_input_ingredient_list=user_input_ingredient.split(", ")

for i in user_input_ingredient_list:

  if i in cleaned_recipe_ingredients_list:

    cleaned_recipe_ingredients_list.remove(i)


recipe_time= recipe_data.iloc[most_similar_index, 2]

str1=", "
recipe_missing_ingredients_str=str1.join(cleaned_recipe_ingredients_list)
cleaned_recipe_missing_ingredients = clean_recipe(recipe_missing_ingredients_str)


print(f"I have an amazing suggestion for you, the recipe's name is: '{cleaned_recipe_name}'.\nIf you would like to try it, here are \n\nTHE MISSING INGREDIENTS:\n{cleaned_recipe_missing_ingredients}\n\nTHE RECIPE:\n{recipe_time} minutes to make.\n{cleaned_recipe_text}.")

#evaluating time
end_time = time.time()

execution_time = end_time - start_time
print("Execution time:", execution_time, "seconds")

# Getting user feedback in order to evaluate the first suggestion, and if the user want another recommendation,
# the program gives the user the second most similar recipe.

control_input=input("Did you like this recipe? Yay or Nay? : ")
similar_recipe_ingredients_copy=similar_recipe_ingredients
max_similar_copy=max_similar
if control_input  == ("Yay" or "yay"):
  print("Amazing! Bon appetit!")
elif control_input  == ("Nay" or "nay"):
  #print(similar_recipe_ingredients)

  similar_recipe_ingredients_copy.pop(most_similar)

  max_similar_copy.pop(most_similar)

  #print(similar_recipe_ingredients)
  #print(max_similar)


  distance2 = []
  most_similar2 = ""

  for i in similar_recipe_ingredients_copy:
  #print(f"distance between {i} and {user_input_ingredient} is: {jaccard_distance(user_input_ingredient,i)}")
    distance2.append(jaccard_distance(user_input_ingredient,i))
    most_similar2=distance2.index(min(distance2))
#print(most_similar2)

  recipe_name = recipe_data.iloc[max_similar[most_similar2], 0]
  recipe_text = recipe_data.iloc[max_similar[most_similar2], 8]
  recipe_ingredients = recipe_data.iloc[max_similar[most_similar2], 10]
  recipe_time= recipe_data.iloc[max_similar[most_similar2], 2]

  cleaned_recipe_text = clean_recipe(recipe_text)



  cleaned_recipe_name = clean_recipe_name(recipe_name.title())


  cleaned_recipe_ingredients = clean_recipe(recipe_ingredients)

  cleaned_recipe_ingredients_list=cleaned_recipe_ingredients.lower().split(", ")
  user_input_ingredient_list=user_input_ingredient.split(", ")

  for i in user_input_ingredient_list:

    if i in cleaned_recipe_ingredients_list:

      cleaned_recipe_ingredients_list.remove(i)


  recipe_time= recipe_data.iloc[most_similar_index, 2]

  str1=", "
  recipe_missing_ingredients_str=str1.join(cleaned_recipe_ingredients_list)
  cleaned_recipe_missing_ingredients = clean_recipe(recipe_missing_ingredients_str)
  print(f"I have another suggestion for you:  the recipe's name is: '{cleaned_recipe_name}'.\nIf you would like to try it, here are \n\nTHE MISSING INGREDIENTS:\n{cleaned_recipe_missing_ingredients}\n\nTHE RECIPE:\n{recipe_time} minutes to make.\n{cleaned_recipe_text}.")


  #print(f"I have another suggestion for you: {recipe_data.iloc[max_similar[most_similar2], 0]} if you would like to try it, here is the recipe: {recipe_data.iloc[max_similar[most_similar2], 8]} ")

else:
    print("Please only type Yay or Nay ðŸ˜¡")

#The codes  below were coded for BloomFilter application in a separate working environment,
#but at the end use of BloomFilter was found to be unnecessary
#therefore the following codes are irrelevant with the working program above, but we wanted to share our work :)

"""!pip3 install bloom-filter
from bloom_filter import BloomFilter
vegetarian_filter = BloomFilter(max_elements=10000, error_rate=0.01)
vegan_filter = BloomFilter(max_elements=1000, error_rate=0.01)
#gluten_free_filter = BloomFilter(max_elements=1000, error_rate=0.01)
non_vegetarian_filter = BloomFilter(max_elements=1000, error_rate=0.01)
breakfast_filter=BloomFilter(max_elements=1000, error_rate=0.01)
lunch_filter=BloomFilter(max_elements=1000, error_rate=0.01)
dinner_filter=BloomFilter(max_elements=1000, error_rate=0.01)
#indian_filter= BloomFilter(max_elements=1000, error_rate=0.1)
#italian_filter=BloomFilter(max_elements=1000, error_rate=0.1)
#turkish_filter=BloomFilter(max_elements=1000, error_rate=0.1)
#french_filter=BloomFilter(max_elements=1000, error_rate=0.1)
#asian_filter=BloomFilter(max_elements=1000, error_rate=0.1)
#mexican_filter=BloomFilter(max_elements=1000, error_rate=0.1)
#non_filter=BloomFilter(max_elements=1000, error_rate=0.1)

vegetarian_filter = set()
vegan_filter = set()
#gluten_free_filter = set()
non_vegetarian_filter=set()
#indian_filter=set()
#mexican_filter=set()
#asian_filter=set()
breakfast_filter=set()
lunch_filter=set()
dinner_filter=set()
#italian_filter=set()
#turkish_filter=set()
#french_filter=set()
#non_filter=set()


for index, row in recipe_data.iterrows():
  cleaned_tags = clean_tags(row['tags'])
     #print(cleaned_tags)
  tags = cleaned_tags.split(',')  # Assuming tags are comma-separated
  tags = [tag.strip() for tag in tags]
  if 'breakfast' in tags:
        breakfast_filter.add(index)
  if 'lunch' in tags:
        lunch_filter.add(index)
  if 'dinner' in tags:
        dinner_filter.add(index)
  if 'vegetarian' in tags:
        vegetarian_filter.add(index)
  if 'vegan' in tags:
        vegan_filter.add(index)
  if 'meat' in tags:
        non_vegetarian_filter.add(index)
  #if 'asian'in tags:
  #      asian_filter.add(index)
  #if 'mexican'in tags:
  #      mexican_filter.add(index)
  #if 'indian'in tags:
  #      indian_filter.add(index)
  #if 'italian'in tags:
  #      italian_filter.add(index)
  #if 'turkish'in tags:
  #  turkish_filter.add(index)
  #if 'french'in tags:
  #  french_filter.add(index)
  #if 'north-american'in tags:
  #  non_filter.add(index)


  #user_input_cuisine = input("Cuisine Preferences: MEXICAN/ASIAN/ITALIAN/TURKISH/INDIAN/FRENCH/NON: ")
user_input_meal = input("Meal: BREAKFAST/LUNCH/DINNER: ")
user_input_vegetarian = input("Dietary Restrictions: VEGETARIAN/VEGAN/NON: ")


  #def cuisine_preference(cuisine_input):
  #if user_input_cuisine == "MEXICAN":
  #  cuisine_filtered=mexican_filter
  #elif user_input_cuisine == "ASIAN":
  #  cuisine_filtered=asian_filter
  #elif user_input_cuisine == "ITALIAN":
  #  cuisine_filtered=italian_filter
  #elif user_input_cuisine == "TURKISH":
  #  cuisine_filtered=turkish_filter
  #elif user_input_cuisine == "INDIAN":
  #  cuisine_filtered=indian_filter
  #elif user_input_cuisine == "FRENCH":
  #  cuisine_filtered=french_filter
  #elif user_input_cuisine == "NON":
  #  cuisine_filtered=non_filter
  #else:
  #  print("Please choose and enter one of the cuisines provided: MEXICAN/ASIAN/ITALIAN/TURKISH/INDIAN/FRENCH/NON")
  #return cuisine_filtered

def meal_preference(meal_input):
  if user_input_meal == "BREAKFAST":
    meal_filtered=breakfast_filter
  elif user_input_meal == "LUNCH":
    meal_filtered=lunch_filter
  elif user_input_meal == "DINNER":
    meal_filtered=dinner_filter
  else:
    print("Please choose and enter one of the cuisines provided: BREAKFAST/LUNCH/DINNER/NON")
  return meal_filtered

def dietary_preference(dietary_input):
  if user_input_vegetarian == "VEGETARIAN":
    dietary_filtered=vegetarian_filter
  elif user_input_vegetarian == "VEGAN":
    dietary_filtered=vegan_filter
  elif user_input_vegetarian == "NON":
    dietary_filtered=non_vegetarian_filter
  else:
    print("Please choose and enter one of the cuisines provided: VEGETARIAN/VEGAN/NON")
  return dietary_filtered




intersected_set = meal_preference(user_input_meal).intersection(dietary_preference(user_input_vegetarian))

print(len(intersected_set))


for index in intersected_set:
    row = recipe_data.loc[index]
    value = str(row.iloc[10])  # Extract value from the 11th column (index 10)
    value_encoded = model.encode(value)
    cosine_list.append(cosine_similarity(input_encoded,value_encoded))"""